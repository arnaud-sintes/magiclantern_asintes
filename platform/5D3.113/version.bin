

Magic Lantern Nightly.2023Sep30.5D3113
Camera   : 5D3
Firmware : 113
Changeset: 051ac5e3b445+ (crop_rec_4k_mlv_snd_isogain_1x3_presets) tip
Built on : 2023-09-30 19:35:00 by asintes@MSI

diff -r 051ac5e3b445 src/lens.c
--- a/src/lens.c	Fri Feb 03 07:05:17 2023 +0100
+++ b/src/lens.c	Sat Sep 30 21:35:01 2023 +0200
@@ -576,6 +576,17 @@
     lvinfo_display(1,0);
 }
 
+
+// is the new lens focus comporment activated?
+static volatile bool lens_focus_ex_comportment = false;
+
+// global lens values (cross-function/handler usage)
+#define LV_FOCUS_DONE__UNSET 0
+#define LV_FOCUS_DONE__OK 1
+#define LV_FOCUS_DONE__ERROR 2
+static volatile int g_lv_focus_done = LV_FOCUS_DONE__UNSET;
+
+// legacy:
 static volatile int lv_focus_requests = 0;
 static volatile int lv_focus_done = 1;
 static volatile int lv_focus_error = 0;
@@ -588,6 +599,15 @@
 // position no matter what's set in menu
 PROP_HANDLER( PROP_LV_FOCUS_DONE )
 {
+if( lens_focus_ex_comportment ) {
+
+	// we're just checking the error flag:
+	g_lv_focus_done = ( buf[ 0 ] & 0x1000 ) ? LV_FOCUS_DONE__ERROR : LV_FOCUS_DONE__OK;
+	
+}
+// legacy comportment:
+else {
+	
     /* turn off the LED we enabled in lens_focus */
     info_led_off();
     
@@ -638,6 +658,8 @@
     }
 
     last_pos = lens_info.focus_pos;
+	
+}
 }
 
 static void
@@ -753,6 +775,105 @@
     return lv_focus_error ? 0 : 1;
 }
 
+
+void wait_for_stabilized_focus_position()
+{
+	// wait until the lens is still:
+	int focus_position_1 = lens_info.focus_pos;
+	bool move_in_progress = true;
+	while( move_in_progress ) {
+		
+		// force position update via PROP_LV_LENS:
+		_prop_lv_lens_request_update();
+		
+		// wait a while:
+		msleep( 200 );
+		
+		// get new position and check if there's a move:
+		const int focus_position_2 = lens_info.focus_pos;
+		move_in_progress = focus_position_1 != focus_position_2;
+		focus_position_1 = focus_position_2;			
+	}
+}
+
+
+bool lens_focus_ex( const unsigned _loop, const unsigned _step_size, const bool _forward, const bool _wait_feedback, const unsigned _sleep_ms )
+{
+	ASSERT( _loop >= 1 );
+	ASSERT( _step_size >= 1 && _step_size <= 3 );
+	
+	// new comportment:
+	lens_focus_ex_comportment = true;
+	
+	// setup proper step_size command value:
+    int step_size = _step_size;
+	if( !_forward ) {
+		step_size += 0x8000;
+	}
+	
+	// for each loop:
+	bool focus_success = true;
+	for( unsigned i = 0; i < _loop && focus_success; i++ ) {
+		
+		// reset focus done:
+		g_lv_focus_done = LV_FOCUS_DONE__UNSET;
+		
+		// current focus position:
+		const int focus_position_before_change = lens_info.focus_pos;
+		
+		// TODO careful with CONFIG_FOCUS_COMMANDS_PROP_NOT_CONFIRMED (reproduce lens_focus comportment here)
+		
+		// ask for lens motor movement:
+		prop_request_change_wait( PROP_LV_LENS_DRIVE_REMOTE, &step_size, 4, 1000 );
+		
+		// wait for focus done:
+		while( g_lv_focus_done == LV_FOCUS_DONE__UNSET ) {
+			
+			// yield:
+			msleep( 1 );
+		}
+		
+		// something went wrong:
+		if( g_lv_focus_done == LV_FOCUS_DONE__ERROR ) {
+			
+			// raise error flag and break:
+			focus_success = false;
+			continue;
+		}
+		
+		// wait for a single position change:
+		while( _wait_feedback && lens_info.focus_pos == focus_position_before_change ) {
+			
+			// force position update via PROP_LV_LENS:
+			_prop_lv_lens_request_update();
+			
+			// yield:
+			msleep( 1 );
+		}
+		
+		// extra sleep as requested by the caller:
+		if( _sleep_ms != 0 ) {
+			msleep( _sleep_ms );
+		}
+	}
+	
+	// if step size is 2 or 3, we need to wait for focus position stabilization:
+	if( _wait_feedback && _step_size > 1 ) {
+		wait_for_stabilized_focus_position();
+	}
+	
+	// don't know what it means (legacy code):
+	idle_wakeup_reset_counters( -10 );
+    lens_display_set_dirty();
+	
+	// back to legacy comportment:
+	lens_focus_ex_comportment = false;
+	
+	// return focus success state:
+	return focus_success;
+}
+
+
 void lens_wait_readytotakepic(int wait)
 {
     int i;
@@ -1705,6 +1826,17 @@
 
 PROP_HANDLER( PROP_LV_LENS )
 {
+if( lens_focus_ex_comportment ) {
+
+	// just update the focus distance & position, avoiding also a memcpy:
+	const struct prop_lv_lens * const lv_lens = ( void * ) buf;
+	lens_info.focus_dist = bswap16( lv_lens->focus_dist );
+    lens_info.focus_pos = ( int16_t ) bswap16( lv_lens->focus_pos );
+	
+}	
+// legacy comportment:
+else {
+	
     ASSERT(len <= sizeof(lv_lens_raw));
     memcpy(&lv_lens_raw, buf, sizeof(lv_lens_raw));
 
@@ -1746,20 +1878,23 @@
     old_focus_pos = lens_info.focus_pos;
     old_focal_len = lens_info.focal_len;
     update_stuff();
+	
+}
 }
 
 /* called once per second */
 void _prop_lv_lens_request_update()
 {
-    /* this property is normally active only in LiveView
-     * however, the MPU can be tricked into sending its value outside LiveView as well
-     * (Canon code also updates these values outside LiveView, when taking a picture)
-     * the input data should not be used, but... better safe than sorry
-     * this should send MPU message 06 04 09 00 00 
-     * and the MPU is expected to reply with the complete property (much larger)
-     * size is model-specific, but should not be larger than sizeof(lv_lens_raw)
-     */
-    prop_request_change(PROP_LV_LENS, &lv_lens_raw, 0);
+		
+	/* this property is normally active only in LiveView
+	 * however, the MPU can be tricked into sending its value outside LiveView as well
+	 * (Canon code also updates these values outside LiveView, when taking a picture)
+	 * the input data should not be used, but... better safe than sorry
+	 * this should send MPU message 06 04 09 00 00 
+	 * and the MPU is expected to reply with the complete property (much larger)
+	 * size is model-specific, but should not be larger than sizeof(lv_lens_raw)
+	 */
+	prop_request_change(PROP_LV_LENS, &lv_lens_raw, 0);
 }
 
 /**
diff -r 051ac5e3b445 src/lens.h
--- a/src/lens.h	Fri Feb 03 07:05:17 2023 +0100
+++ b/src/lens.h	Sat Sep 30 21:35:01 2023 +0200
@@ -557,4 +557,35 @@
 /* force an update of PROP_LV_LENS outside LiveView */
 void _prop_lv_lens_request_update();
 
+// new lens focus function:
+//
+// _loop: 			indicate the number of loop to perform usint the given step size
+//					remark: must be >= 1 (assertion)
+// _step_size: 		indicate the size of one step
+//					remark: must be 1, 2 or 3 (assertion)
+//					note: this doesn't correspond to a reliable step count, meaning
+//					a 1x loop of step size "3" is not equivalent to a 3x loops of step size "1"
+//					e.g.: on my Canon 24mm lens, only "1" is reliable (1 real step move),
+//					"2" doing 4 steps move and "3" doing 26 steps move -> must be calibrated
+// _forward: 		are we moving forward or backward?
+//					note: "forward" and "backward" depends of the lens
+// _wait_feedback:	do we wait for proper focus position feedback or not?
+//					note: when disabled, the move is faster but focus distance & position values
+//					(focus_dist & focus_pos) set in the lens_info structure are not reliable
+//					until there are "stabilized", whereas when enabled the values are guaranteed
+//					to be properly usable after the lens_focus_ex() function call
+// _sleep_ms: 		how much ms do we want to sleep a bit between each loop
+//					remark: can be 0
+//
+// for better understanding, please note the following information around focus position:
+// - position values are dependent of the lens rotor position at camera startup (no "absolute" reference)
+// - this initial reference will be reset anytime we do a manual focus operation, but is ok with auto-focus
+// - positions reference value can be negative (lens dependent)
+// - position values progression is non-linear (~exponential, lens dependent)
+// - a forward rotor move can be translated as a positive or negative step (lens dependent)
+bool lens_focus_ex( const unsigned _loop, const unsigned _step_size, const bool _forward, const bool _wait_feedback, const unsigned _sleep_ms );
+
+// wait for a stabilized focus position, that may not be immediate when dealing with step size of 2 or 3 (multiple increments after the move query):
+void wait_for_stabilized_focus_position();
+
 #endif /* _lens_h_ */
diff -r 051ac5e3b445 src/raw.c
--- a/src/raw.c	Fri Feb 03 07:05:17 2023 +0100
+++ b/src/raw.c	Sat Sep 30 21:35:01 2023 +0200
@@ -2205,44 +2205,517 @@
     free(lv2rx);
 }
 
-void FAST raw_preview_fast_ex(void* raw_buffer, void* lv_buffer, int y1, int y2, int quality)
+
+// *** cached ultrafast preview:
+//
+// The purpose is to reduce as much as possible the computation time required to perform the framed RAW
+// preview rendering in LiveView in order to save CPU time to do other tasks (e.g.: recording RAW data).
+//
+// This is achieved by precomputing everything possible, notably the RAW buffer offsets and the RGB
+// gamma transformations, so the drawing itself may consist in the lightest possible loop doing linear
+// accesses to data, thanks to simple pointer dereferencing.
+//
+// By doing this in colored and grayscale preview we instantly get a smoother preview (both previewing &
+// during recording), allowing us to potentially reducing the sleep times defined to leave enough headroom
+// for the CPU to record the RAW data.
+//
+// The cache precomputation is managed by simply computing a determinant value that may change when
+// selecting a new RAW video resolution.
+
+
+// ultrafast cache structure:
+typedef struct
+{
+    // used to determine if we need to (re)init the cache:
+    uint64_t determinant;
+    
+    // raw offsets pointer:
+    uint32_t * p_raw_offsets;
+    // pointer to the last useful data in the buffer:
+    const uint32_t * p_raw_offsets_last;
+    
+    // pointer to the first useful offset in LV:
+    uint32_t p_first_lv_offset;
+    
+    // gamma LUT for red & blue channels (RGB) and for green channel (RGB & luminance in grayscale):
+    // [memory footprint] 2 slot x 1024 values x 8bits = 2KB
+    uint8_t gamma_rb[ 1024 ];
+    uint8_t gamma_g[ 1024 ];
+    
+    // raw width stride, used to go from even to odd lines:
+    uint32_t rawStride;
+}
+preview_ultrafast_cache;
+
+// unique preview ultrafast cache:
+static preview_ultrafast_cache g_preview_ultrafast_cache = {
+    .determinant = 0,   // voided before first initialization
+    .p_raw_offsets = 0  // must be allocated the very first time
+};
+
+
+// preview statistics structure:
+typedef struct
+{
+    // how many frame do we want to draw before dumping averaged statistics?
+    const int dump_frame_count;
+    
+    // time point (ms) set before the first framed preview draw call:
+    int clock_before_first_draw_ms;
+    
+    // cumulated time (ms) of preview draw calls:
+    int cumulated_draw_time_ms;
+    
+    // currently drawn preview frame count:
+    int drawn_frame_count;
+}
+preview_statistics;
+
+// unique preview statistics:
+static preview_statistics g_preview_statistics = {
+    .dump_frame_count = 100,            // dump every 100 frame
+    .clock_before_first_draw_ms = 0,
+    .cumulated_draw_time_ms = 0,
+    .drawn_frame_count = 0 
+};
+
+// reset statistics:
+void reset_preview_statistics()
+{
+    g_preview_statistics.clock_before_first_draw_ms = 0;
+    g_preview_statistics.cumulated_draw_time_ms = 0;
+    g_preview_statistics.drawn_frame_count = 0;
+}
+
+
+// preview ultrafast parameters container:
+static int g_framed_preview_param[ 7 ];
+
+void set_framed_preview_param( const int _param, const int _value )
+{
+    g_framed_preview_param[ _param ] = _value;
+}
+
+int get_framed_preview_param( const int _param )
+{
+    return g_framed_preview_param[ _param ];
+}
+
+
+// ultrafast preview cache initialization:
+static bool FAST init_preview_ultrafast_cache( const int _y1, const int _y2, const bool _quarter )
 {
-    if (raw_info.bits_per_pixel != 14)
-        return;
-
-    yuv422_buffer_check();
-
-    if (raw_buffer == (void*)-1)
-        raw_buffer = (void*)raw_info.buffer;
+    // notation shortcut:
+    preview_ultrafast_cache * puc = &g_preview_ultrafast_cache;
+   
+    // precompute gamma conversions, using a 10bits (1024 values) LUT converted to 14 bits color data.
+    // red & blue components are converted over 11bits while green remains on 10bits to follow a
+    // 2-1-2 (R-G-B) pattern and get a proper white balance.
+    // red, green & blue components are using a xÂ² ramp and stored on 8bits (256 values)
+    float gamma_ev = 0, gamma = 0;
+    for( int i = 0; i < 1024; i++ ) {
+        
+        // get gamma in ev range:
+        gamma_ev = raw_to_ev( i << 4 );
+        
+        // 8-bits gamma value for red & blue:
+        gamma = ( COERCE( gamma_ev + 11, 0, 10 ) * 255 ) / 10;
+        puc->gamma_rb[ i ] = ( gamma * gamma ) / 255;
+        
+        // 8-bits gamma value for green:
+        gamma = ( COERCE( gamma_ev + 10, 0, 10 ) * 255 ) / 10;
+        puc->gamma_g[ i ] = ( gamma * gamma ) / 255;
+    }
+   
+    // remember current RAW data stride (used to switch from even to odd rows):
+    puc->rawStride = raw_info.width >> 3;
+
+    // create RAW offset buffer the very first time, using the maximum LV (half) resolution:
+    // [memory footprint] ( half LV width [720 / 2] ) x LV height [480] x 32bits (offset) = 675KB
+    if( puc->p_raw_offsets == 0 ) {
+        puc->p_raw_offsets = malloc( ( ( vram_lv.width * vram_lv.height ) >> 1 ) * sizeof( uint32_t ) );
+        if( puc->p_raw_offsets == 0 ) {
+            printf( "ERROR: ultrafast cache allocation failure!\n" );
+            return false; // memory allocation failure
+        }
+    }
+    // point to the data origin to feed the buffer:
+    uint32_t * p_raw_offsets = puc->p_raw_offsets;
+   
+    // compute left and right boundaries:
+    int x1 = COERCE( RAW2LV_X( preview_rect_x ), 0, vram_lv.width );
+    int x2 = COERCE( RAW2LV_X( preview_rect_x + preview_rect_w ), 0, vram_lv.width );
+    if( x2 < x1 ) {
+        return false; // wtf?
+    }
+    
+    // cache LV to RAW horizontal transformations (same for all the rows):
+    int * p_lv2raw_x = malloc( vram_lv.width * sizeof( int ) );
+    if( p_lv2raw_x == 0 ) {
+        return false; // allocation failure
+    }
+    for( int x = x1; x < x2; x++ ) {
+        p_lv2raw_x[ x ] = LV2RAW_X( x ) & ~1;
+    }
+    
+    // reset first useful LV offset for subsequent set:
+    puc->p_first_lv_offset = 0;
+    
+    // offset shifting & pixel skiping values depends of half or quarter resolution:
+    const int lv_offset_shift = _quarter ? 3 : 2;
+    const int lv_pixel_skip = _quarter ? 4 : 2;
     
-    if (lv_buffer == (void*)-1)
-        lv_buffer = (void*)YUV422_LV_BUFFER_DISPLAY_ADDR;
+    // for each useful LV row:
+    for( int y = _y1; y < _y2; y++ ) {
+        
+        // compute RAW vertical position:
+        int yr = LV2RAW_Y( y ) & ~1;
+        // nothing to do if outside boundaries:
+        if( yr <= preview_rect_y || yr >= preview_rect_y + preview_rect_h ) {
+            continue;
+        }
+            
+        // remember the first useful offset in LiveView, then we will increment linearly:
+        if( puc->p_first_lv_offset == 0 )
+            puc->p_first_lv_offset = ( y * ( vram_lv.width << 1 ) ) >> lv_offset_shift;
+        
+        // for each LV column (half or quarter LV horizontal resolution):
+        for( int x = 0; x < vram_lv.width; x += lv_pixel_skip ) {
+            
+            // outside horizontal boudaries, set offset to null:
+            if( x < x1 || x >= x2 ) {
+                *p_raw_offsets++ = ( uint32_t ) -1;
+                continue;
+            }
+            
+            // compute RAW buffer offset, pointing to the red component of the 1st of the 8 pixel groups:
+            *p_raw_offsets++ = ( p_lv2raw_x[ x ] + yr * raw_info.width ) >> 3;
+        }
+    }
+    
+    // release LV to RAW cache:
+    free( p_lv2raw_x );
     
-    if (y1 == -1)
-        y1 = BM2LV_Y(os.y0);
+    // save last useful pointer to RAW offset:
+    puc->p_raw_offsets_last = p_raw_offsets;
+       
+    // done:
+    return true;
+}
+
+
+// optimize a bit the RGB to YUV422 conversion routine:
+__attribute__( ( always_inline ) ) static uint32_t _rgb2yuv422_rec709( const int _r, const int _g, const int _b )
+{
+    // Y computation from RGB:
+    int y = ( 217 * _r + 732 * _g + 73 * _b ) >> 10;
+    if( y > 255 ) y = 255;
+    
+    // Y computation from RGB:
+    int u = ( -117 * _r - 394 * _g + 512 * _b ) / 1024;
+    if( u < -128 ) u = -128; else if( u > 127 ) u = 127;
+    
+    // V computation from RGB:
+    int v = ( 512 * _r -465 * _g - 46 * _b ) / 1024;
+    if( v < -128 ) v = -128; else if( v > 127 ) v = 127;
+    
+    // YUV422 computation:
+    return ( u & 0xFF ) | ( y << 8 ) | ( ( v & 0xFF ) << 16 ) | ( y << 24 );
+}
+
+
+// template definitions for the drawing routine itself (covers both color/grayscale, half/quarter resolution):
+
+#define T_PREVIEW_ULTRAFAST_DRAW_READ_COLOR                                                        \
+    /* point to the RAW red value on the current even line: */                                     \
+    p_raw_pointer = p_raw_buffer + raw_offset;                                                     \
+    /* get red value: */                                                                           \
+    r = *( p_gamma_rb + ( p_raw_pointer->a >> 4 ) );                                               \
+    /* get green & blue values on the next odd line: */                                            \
+    p_raw_pointer += rawStride;                                                                    \
+    /* get green value: */                                                                         \
+    g = *( p_gamma_g + ( p_raw_pointer->a >> 4 ) );                                                \
+    /* get blue value: */                                                                          \
+    b = *( p_gamma_rb + ( ( ( p_raw_pointer->b_hi << 12 ) | p_raw_pointer->b_lo ) >> 4 ) );        \
+                                                                                                   \
+    /* RGB conversion to YUV422: */                                                                \
+    yuv = _rgb2yuv422_rec709( r, g, b )
+
     
-    if (y2 == -1)
-        y2 = BM2LV_Y(os.y_max);
+#define T_PREVIEW_ULTRAFAST_DRAW_READ_GRAYSCALE                                                    \
+    /* compute Y component based over the green component (closest odd line) in the RAW buffer, */ \
+    /* using gamma LUT: */                                                                         \
+    y = *( p_gamma_g + ( ( p_raw_buffer + raw_offset )->a >> 4 ) )
+
+
+#define T_PREVIEW_ULTRAFAST_DRAW_WRITE_COLOR_HALF                                                  \
+    /* set YUV data in the LV buffer (one YUV422 32-bits pixels): */                               \
+    *p_lv_buffer++ = yuv
+
+
+#define T_PREVIEW_ULTRAFAST_DRAW_WRITE_COLOR_QUARTER                                               \
+    /* set YUV data in the LV buffer (2 duplicated YUV422 32-bits pixels): */                      \
+    *p_lv_buffer++ = ( yuv << 32 ) | yuv
+
+    
+#define T_PREVIEW_ULTRAFAST_DRAW_WRITE_GRAYSCALE_HALF                                              \
+    /* set YUV data in the LV buffer (1 pixel of 32-bits YUV422 grayscale data, */                 \
+    /* meaning two times the same Y value with no chrominance data): */                            \
+    *p_lv_buffer++ = ( y << 8 ) | ( y << 24 )
+
     
-    if (quality == -1)
-        quality = 0;
+#define T_PREVIEW_ULTRAFAST_DRAW_WRITE_GRAYSCALE_QUARTER                                           \
+    /* set YUV data in the LV buffer (2 pixels duplication of 32-bits YUV422 grayscale data, */    \
+    /* meaning two times the same Y value with no chrominance data): */                            \
+    *p_lv_buffer++ = ( y << 8 ) | ( y << 24 ) | ( y << 40 ) | ( y << 56 )
+
+
+#define T_PREVIEW_ULTRAFAST_DRAW( _LV_POINTER_TYPE, _READ_FN, _WRITE_FN )                          \
+    /* get LV buffer pointer: */                                                                   \
+    register _LV_POINTER_TYPE * p_lv_buffer = p_lv_buffer_void;                                    \
+                                                                                                   \
+    /* set LV buffer at its first useful position: */                                              \
+    p_lv_buffer += puc->p_first_lv_offset;                                                         \
+                                                                                                   \
+    /* fast linear access: */                                                                      \
+    while( p_raw_offsets != p_raw_offsets_last ) {                                                 \
+                                                                                                   \
+        /* get RAW offset: */                                                                      \
+        raw_offset = *p_raw_offsets++;                                                             \
+                                                                                                   \
+        /* offset is null, skip this pixel (left & right black bars): */                           \
+        if( raw_offset == ( uint32_t ) -1 ) {                                                      \
+            p_lv_buffer++;                                                                         \
+            continue;                                                                              \
+        }                                                                                          \
+                                                                                                   \
+        /* variable read function: */                                                              \
+        _READ_FN;                                                                                  \
+                                                                                                   \
+        /* variable feed function */                                                               \
+        _WRITE_FN;                                                                                 \
+    }
+
+
+// ultra fast preview generic drawing routine:
+static void FAST draw_preview_ultrafast( const void * _p_raw_buffer, const void * _p_lv_buffer, const int _y1, const int _y2, const bool _reinit, const bool _grayscale, const bool _quarter )
+{   
+    // notation shortcut:
+    const preview_ultrafast_cache * const puc = &g_preview_ultrafast_cache;
+   
+    // init cache if needed (determined externally):
+    if( _reinit && !init_preview_ultrafast_cache( _y1, _y2, _quarter ) ) {
+        return; // fail to init ultrafast cache
+    }
+   
+    // get LV buffer pointer:
+    register void * p_lv_buffer_void = CACHEABLE( _p_lv_buffer );
+    if( p_lv_buffer_void == 0 ) {
+        return; // unavailable buffer
+    }
+   
+    // get cacheable RAW buffer pointer:
+    const struct raw_pixblock * p_raw_buffer = CACHEABLE( _p_raw_buffer );
+    if( p_raw_buffer == 0 ) {
+        return; // unavailable buffer
+    }
+    
+    // [grayscale] we need to point directly to an odd line:
+    if( _grayscale ) {
+        p_raw_buffer += puc->rawStride;
+    }
+
+    // [color] independent r, g, & b components:
+    int r = 0, g = 0, b = 0;
+    // [color] combined 32bits YUV value (stored on 64bits for subsequent shift):
+    int64_t yuv = 0;
+    // [grayscale] Y component (luminance) of the YUV422 LV output buffer:
+    int64_t y = 0;
+    
+    // pointer to precomputed RAW offsets:
+    const uint32_t * p_raw_offsets = puc->p_raw_offsets;
+    if( p_raw_offsets == 0 ) {
+        return; // ultrafast preview cache not initialized
+    }
+    // point to last RAW offset:
+    const uint32_t * const p_raw_offsets_last = puc->p_raw_offsets_last;
+    
+    // [color] pointer to RAW data, used to switch between R, G & B components on even & odd lines:
+    register const struct raw_pixblock * p_raw_pointer = 0;
+    
+    // [color] RAW stride used to switch from even to odd lines:
+    const uint32_t rawStride = puc->rawStride;
+    
+    // [color] pointer to red+blue gamma LUT:
+    const uint8_t * const p_gamma_rb = puc->gamma_rb;
+    // pointer to green gamma LUT:
+    const uint8_t * const p_gamma_g = puc->gamma_g;
+    
+    // RAW offet value:
+    uint32_t raw_offset = 0;
+   
+    // quarter resolution:
+    if( _quarter ) {
+        // [grayscale]:
+        if( _grayscale ) {
+            T_PREVIEW_ULTRAFAST_DRAW( uint64_t, T_PREVIEW_ULTRAFAST_DRAW_READ_GRAYSCALE, T_PREVIEW_ULTRAFAST_DRAW_WRITE_GRAYSCALE_QUARTER );
+            return;
+        }
+        // [color]:
+        T_PREVIEW_ULTRAFAST_DRAW( uint64_t, T_PREVIEW_ULTRAFAST_DRAW_READ_COLOR, T_PREVIEW_ULTRAFAST_DRAW_WRITE_COLOR_QUARTER );        
+        return;
+    }
     
-    switch (quality)
-    {
-        case RAW_PREVIEW_GRAY_ULTRA_FAST:
-            raw_preview_fast_work(raw_buffer, lv_buffer, y1, y2);
-            break;
+    // half resolution:
+    // [grayscale]:
+    if( _grayscale ) {
+        T_PREVIEW_ULTRAFAST_DRAW( uint32_t, T_PREVIEW_ULTRAFAST_DRAW_READ_GRAYSCALE, T_PREVIEW_ULTRAFAST_DRAW_WRITE_GRAYSCALE_HALF );
+        return;
+    }
+    // [color]:
+    T_PREVIEW_ULTRAFAST_DRAW( uint32_t, T_PREVIEW_ULTRAFAST_DRAW_READ_COLOR, T_PREVIEW_ULTRAFAST_DRAW_WRITE_COLOR_HALF );
+}
+
+
+// printf doesn't seems to be able to dump float value, so here's a function that splits
+// a float value to a "x.y" string, with 3 numbers after the dot:
+char * format_float( const double _value, char * _buffer, const size_t _buffer_len )
+{
+    const int left = ( int ) _value;
+    const int right = ( ( int )( _value * 1000 ) ) - ( left * 1000 );
+    snprintf( _buffer, _buffer_len - 1, "%d.%d", left, right );
+    return _buffer;
+}
+
+
+// updated drawing routine with an additional recording parameter:
+void FAST raw_preview_fast_ex2( void * _p_raw_buffer, void * _p_lv_buffer, int _y1, int _y2, int _quality, const bool _recording )
+{
+    // only support 14-bits data:
+    if( raw_info.bits_per_pixel != 14 ) {
+        return;
+    }
+
+    // check if the YUV buffer is initialized:
+    yuv422_buffer_check();
+
+    // set default values if needed:
+    _p_raw_buffer = ( _p_raw_buffer == ( void * ) -1 ) ? ( void * ) raw_info.buffer : _p_raw_buffer;
+    _p_lv_buffer = ( _p_lv_buffer == ( void * ) -1 ) ? ( void * ) YUV422_LV_BUFFER_DISPLAY_ADDR : _p_lv_buffer;
+    _y1 = ( _y1 == -1 ) ? BM2LV_Y( os.y0 ) : _y1;
+    _y2 = ( _y2 == -1 ) ? BM2LV_Y( os.y_max ) : _y2;
+    _quality = ( _quality == -1 ) ? RAW_PREVIEW_ADAPTIVE : _quality;
+    
+    // determine final style & resolution:
+    int style = -1;
+    int resolution = -1;
+    
+    // forced colored/half resolution:
+    if( _quality == RAW_PREVIEW_COLOR_HALFRES ) {
+        style = FRAMED_PREVIEW_PARAM__STYLE__COLORED;
+        resolution = FRAMED_PREVIEW_PARAM__RESOLUTION_HALF;
+    }
+    else
+    // forced grayscaled/quarter resolution:
+    if( _quality == RAW_PREVIEW_GRAY_ULTRA_FAST ) {
+        style = FRAMED_PREVIEW_PARAM__STYLE__GRAYSCALED;
+        resolution = FRAMED_PREVIEW_PARAM__RESOLUTION_QUARTER;
+    }
+    // adaptive quality, depends of idle/recording settings:
+    else{
         
-        case RAW_PREVIEW_COLOR_HALFRES:
-        default:
-            raw_preview_color_work(raw_buffer, lv_buffer, y1, y2);
-            break;
+        // recording state:
+        if( _recording ) {
+            style = g_framed_preview_param[ FRAMED_PREVIEW_PARAM__RECORDING_STYLE ];
+            resolution = g_framed_preview_param[ FRAMED_PREVIEW_PARAM__RECORDING_RESOLUTION ];
+        }
+        // non-recording (idle) states:
+        else {
+            style = g_framed_preview_param[ FRAMED_PREVIEW_PARAM__IDLE_STYLE ];
+            resolution = g_framed_preview_param[ FRAMED_PREVIEW_PARAM__IDLE_RESOLUTION ];
+        }
+
+        // legacy engine, the resolution depends of style (colored: half, grayscaled: quarter):
+        // note anyway this updated resolution parameter will not be used by legacy code
+        if( g_framed_preview_param[ FRAMED_PREVIEW_PARAM__ENGINE ] == FRAMED_PREVIEW_PARAM__ENGINE__LEGACY ) {
+            resolution = ( style == FRAMED_PREVIEW_PARAM__STYLE__COLORED ) ? FRAMED_PREVIEW_PARAM__RESOLUTION_HALF : FRAMED_PREVIEW_PARAM__RESOLUTION_QUARTER;
+        }
+    }
+    
+    // compute the current determinant value based over RAW state & framed preview configuration:
+    const uint64_t ultrafast_determinant =
+        ( preview_rect_x * preview_rect_y ) + ( preview_rect_w * preview_rect_h ) +
+        ( raw_info.black_level * raw_info.white_level ) + ( _y1 * _y2 ) +
+        ( ( style << 2 ) | ( resolution << 1 ) | g_framed_preview_param[ FRAMED_PREVIEW_PARAM__ENGINE ] );
+
+    // different determinant? then we need to reinit the preview cache:
+    const bool reinit_preview_cache = ultrafast_determinant != g_preview_ultrafast_cache.determinant;
+    
+    // do we have to compute & dump preview statistics?
+    const bool dump_preview_statistics = g_framed_preview_param[ FRAMED_PREVIEW_PARAM__STATISTICS ];
+    
+    // framed preview statistics computation:
+    int clock_before_draw_ms = 0, clock_after_draw_ms = 0;
+    if( !reinit_preview_cache && dump_preview_statistics ) {
+        clock_before_draw_ms = get_ms_clock();
+        if( g_preview_statistics.clock_before_first_draw_ms == 0 )
+            g_preview_statistics.clock_before_first_draw_ms = clock_before_draw_ms;
+    }
+    
+    // call legacy drawing routing:
+    if( g_framed_preview_param[ FRAMED_PREVIEW_PARAM__ENGINE ] == FRAMED_PREVIEW_PARAM__ENGINE__LEGACY ) {
+        // colored (half resolution):
+        if( style == FRAMED_PREVIEW_PARAM__STYLE__COLORED ) {
+            raw_preview_color_work( _p_raw_buffer, _p_lv_buffer, _y1, _y2 );
+        }
+        // grayscaled (quarter resolution):
+        else {
+            raw_preview_fast_work( _p_raw_buffer, _p_lv_buffer, _y1, _y2 );
+        }
+    }
+    // call ultrafast (unique) drawing routine:
+    else {
+        draw_preview_ultrafast( _p_raw_buffer, _p_lv_buffer, _y1, _y2, reinit_preview_cache, style == FRAMED_PREVIEW_PARAM__STYLE__GRAYSCALED, resolution == FRAMED_PREVIEW_PARAM__RESOLUTION_QUARTER );
+    }
+    
+    // framed preview statistics computation & dump:
+    if( !reinit_preview_cache && dump_preview_statistics ) {
+        clock_after_draw_ms = get_ms_clock();
+        g_preview_statistics.cumulated_draw_time_ms += ( clock_after_draw_ms - clock_before_draw_ms );
+        if( ++g_preview_statistics.drawn_frame_count == g_preview_statistics.dump_frame_count ) {
+            const double drawn_frame_count = g_preview_statistics.drawn_frame_count;
+            const double preview_routine_duration_ms = ( ( double ) g_preview_statistics.cumulated_draw_time_ms ) / drawn_frame_count;
+            const double display_fps = drawn_frame_count * 1000 / ( ( double ) ( clock_after_draw_ms - g_preview_statistics.clock_before_first_draw_ms ) );
+            char ms_buffer[ 32 ], fps_buffer[ 32 ];
+            printf( "[Framed preview] %sms %sfps\n", format_float( preview_routine_duration_ms, ms_buffer, 32 ), format_float( display_fps, fps_buffer, 32 ) );
+            reset_preview_statistics();
+        }
+    }
+        
+    // we've just reconfigured ultrafast cache:
+    if( reinit_preview_cache ) {
+        
+        // save new determinant:
+        g_preview_ultrafast_cache.determinant = ultrafast_determinant;
+        
+        // reset statistics to avoid bad values:
+        reset_preview_statistics();
+        
+        // cleanup the whole liveview, implicitly creating black bars where needed:
+        memset( CACHEABLE( _p_lv_buffer ), 0, ( vram_lv.width * vram_lv.height ) << 1 );
     }
 }
 
+
+void FAST raw_preview_fast_ex( void * _p_raw_buffer, void * _p_lv_buffer, const int _y1, const int _y2, int const _quality )
+{
+    raw_preview_fast_ex2( _p_raw_buffer, _p_lv_buffer, _y1, _y2, _quality, false );
+}
+
+
 void FAST raw_preview_fast()
 {
-    raw_preview_fast_ex((void*)-1, (void*)-1, -1, -1, -1);
+    raw_preview_fast_ex2( ( void * ) -1, ( void * ) -1, -1, -1, -1, false );
 }
 
 #ifdef CONFIG_RAW_LIVEVIEW
diff -r 051ac5e3b445 src/raw.h
--- a/src/raw.h	Fri Feb 03 07:05:17 2023 +0100
+++ b/src/raw.h	Sat Sep 30 21:35:01 2023 +0200
@@ -113,6 +113,42 @@
 #define GRAY_PROJECTION_BRIGHT_ONLY      0x100 /* you can also analyze the bright exposure (suitable for shadows, SNR... */
 #define GRAY_PROJECTION_DARK_AND_BRIGHT  0x200 /* warning: might be more accurate on regular images, but has undefined behavior on dual ISO images */
 
+// framed preview parameters:
+#define FRAMED_PREVIEW_PARAM__ENGINE                0    // engine type to use to deal with framed preview
+#define FRAMED_PREVIEW_PARAM__IDLE_STYLE            1    // style to apply when idle
+#define FRAMED_PREVIEW_PARAM__IDLE_RESOLUTION       2    // resolution to apply when idle
+#define FRAMED_PREVIEW_PARAM__RECORDING_STYLE       3    // style to apply when recording
+#define FRAMED_PREVIEW_PARAM__RECORDING_RESOLUTION  4    // resolution to apply when recording
+#define FRAMED_PREVIEW_PARAM__TIMING                5    // timing policy
+#define FRAMED_PREVIEW_PARAM__STATISTICS            6    // statistics dump state
+
+// framed preview engine values:
+#define FRAMED_PREVIEW_PARAM__ENGINE__LEGACY        0    // "legacy" engine
+#define FRAMED_PREVIEW_PARAM__ENGINE__ULTRAFAST     1    // ultrafast (cached) engine
+
+// framed preview style values:
+#define FRAMED_PREVIEW_PARAM__STYLE__COLORED        0    // colored display
+#define FRAMED_PREVIEW_PARAM__STYLE__GRAYSCALED     1    // grayscaled display (faster)
+
+// framed preview resolution values:
+#define FRAMED_PREVIEW_PARAM__RESOLUTION_HALF       0    // half resolution (more accurate)
+#define FRAMED_PREVIEW_PARAM__RESOLUTION_QUARTER    1    // quarter resolution (faster)
+
+// framed preview timing values:
+#define FRAMED_PREVIEW_PARAM__TIMING__LEGACY        0    // "legacy" timing (regular sleep statements)
+#define FRAMED_PREVIEW_PARAM__TIMING__TEMPERED      1    // tempered timing policy, affecting idle only
+#define FRAMED_PREVIEW_PARAM__TIMING__AGRESSIVE     2    // agressive timing, affecting also recording
+
+// framed preview statistics values:
+#define FRAMED_PREVIEW_PARAM__STATISTICS_OFF        0    // deactivated statistics console dump
+#define FRAMED_PREVIEW_PARAM__STATISTICS_ON         1    // activated statistics console dump
+
+// change the value of a given framed preview parameter:
+void set_framed_preview_param( const int _param, const int _value );
+
+// get the current value of a given framed preview parameter:
+int get_framed_preview_param( const int _param );
+
 /* input: 0 - 16384 (valid range: from black level to white level) */
 /* output: -14 ... 0 */
 float raw_to_ev(int raw);
@@ -122,9 +158,15 @@
 void raw_preview_fast();
 
 /* pass -1 if default value for some parameter is fine */
-void raw_preview_fast_ex(void* raw_buffer, void* lv_buffer, int start_line, int end_line, int quality);
-#define RAW_PREVIEW_COLOR_HALFRES   0   /* 360x480 color, pretty slow */
-#define RAW_PREVIEW_GRAY_ULTRA_FAST 1   /* 180x240, aims to be real-time */
+void raw_preview_fast_ex( void * _p_raw_buffer, void * _p_lv_buffer, int _y1, int _y2, int _quality );
+
+// possible quality values:
+#define RAW_PREVIEW_COLOR_HALFRES   0    // 360x480 color, pretty slow
+#define RAW_PREVIEW_GRAY_ULTRA_FAST 1    // 180x240, aims to be real-time
+#define RAW_PREVIEW_ADAPTIVE        2    // choice depends on idle & recording framed preview settings
+
+// updated framed preview drawing routine, requiring an additional recording state:
+void raw_preview_fast_ex2( void * _p_raw_buffer, void * _p_lv_buffer, const int _y1, const int _y2, const int _quality, const bool _recording );
 
 /* request/release/check LiveView RAW flag (lv_save_raw) */
 /* you have to call request/release in pairs (be careful not to request once and release twice) */
diff -r 051ac5e3b445 src/shoot.c
--- a/src/shoot.c	Fri Feb 03 07:05:17 2023 +0100
+++ b/src/shoot.c	Sat Sep 30 21:35:01 2023 +0200
@@ -1869,7 +1869,9 @@
     lens_set_kelvin(k);
 }
 
-PROP_INT( PROP_WB_KELVIN_PH, wb_kelvin_ph );
+// multiple definitions (1st: lens.c:1738)
+//PROP_INT( PROP_WB_KELVIN_PH, wb_kelvin_ph );
+extern volatile uint32_t wb_kelvin_ph;
 
 static MENU_UPDATE_FUNC(kelvin_display)
 {




